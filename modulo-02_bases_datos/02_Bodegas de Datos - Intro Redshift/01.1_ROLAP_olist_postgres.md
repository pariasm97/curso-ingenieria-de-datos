# Operaciones OLAP con PostgreSQL y el dataset Olist

Este documento muestra cómo implementar las operaciones OLAP clásicas

## 0. Contexto y tabla base

Definimos una **vista lógica** que usaremos en casi todos los ejemplos:

```sql
WITH fact_olist_sales AS (
    SELECT
        oi.order_id,
        o.customer_id,
        c.customer_city,
        c.customer_state,
        p.product_category_name,
        o.order_status,
        o.order_purchase_timestamp::date AS order_date,
        oi.price,
        oi.freight_value,
        (oi.price + oi.freight_value) AS revenue
    FROM olist_order_items AS oi
    JOIN olist_orders       AS o ON o.order_id = oi.order_id
    JOIN olist_customers    AS c ON c.customer_id = o.customer_id
    JOIN olist_products     AS p ON p.product_id = oi.product_id
)
SELECT *
FROM fact_olist_sales
LIMIT 10;
```

En los ejemplos siguientes se asume que partes de una CTE o vista similar
llamada `fact_olist_sales`.

---

## 1. Add measure

**Idea:** añadir nuevas medidas calculadas a partir de otras.

Ejemplo: crear medidas derivadas de `revenue`.

```sql
WITH fact_olist_sales AS ( ... )
SELECT
    order_id,
    product_category_name,
    revenue,
    revenue * 0.7 AS estimated_cost,
    revenue - revenue * 0.7 AS estimated_profit
FROM fact_olist_sales;
```

Aquí **Add measure** son `estimated_cost` y `estimated_profit`.

---

## 2. Aggregation operations

**Idea:** agregar celdas del cubo usando funciones de agregación.

Ejemplo: ventas mensuales por categoría de producto.

```sql
WITH fact_olist_sales AS ( ... )
SELECT
    date_trunc('month', order_date) AS order_month,
    product_category_name,
    SUM(revenue)                    AS total_revenue,
    COUNT(DISTINCT order_id)        AS num_orders
FROM fact_olist_sales
GROUP BY 1, 2
ORDER BY 1, 2;
```

---

## 3. Dice

**Idea:** quedarte solo con las celdas que cumplen una condición booleana
sobre dimensiones y/o medidas.

Ejemplo: clientes de SP o RJ, categoría “bed_bath_table”, tickets altos.

```sql
WITH fact_olist_sales AS ( ... )
SELECT
    order_id,
    customer_state,
    product_category_name,
    revenue
FROM fact_olist_sales
WHERE
    order_date BETWEEN DATE '2017-01-01' AND DATE '2017-12-31'
    AND customer_state IN ('SP','RJ')
    AND product_category_name = 'bed_bath_table'
    AND revenue > 100;
```

---

## 4. Difference

**Idea:** restar las celdas de un cubo que también están en otro cubo
(mismo esquema).

Ejemplo: pedidos que **no** han sido entregados.

```sql
WITH fact_olist_sales AS ( ... ),
cube_all AS (
    SELECT
        order_id,
        customer_id,
        order_date,
        revenue
    FROM fact_olist_sales
),
cube_delivered AS (
    SELECT
        order_id,
        customer_id,
        order_date,
        revenue
    FROM fact_olist_sales
    WHERE order_status = 'delivered'
)
SELECT *
FROM cube_all
EXCEPT
SELECT *
FROM cube_delivered;
```

El resultado es el cubo “todas las órdenes” menos el cubo “órdenes entregadas”.

---

## 5. Drill-across

**Idea:** combinar dos cubos distintos que comparten dimensiones compatibles.

Ejemplo: cruzar ventas y reviews por mes y estado del cliente.

```sql
WITH fact_olist_sales AS ( ... ),
cube_sales AS (
    SELECT
        date_trunc('month', order_date) AS order_month,
        customer_state,
        SUM(revenue)                    AS total_revenue
    FROM fact_olist_sales
    GROUP BY 1, 2
),
cube_reviews AS (
    SELECT
        date_trunc('month', o.order_purchase_timestamp)::date AS order_month,
        c.customer_state,
        AVG(r.review_score)                                   AS avg_review_score
    FROM olist_order_reviews AS r
    JOIN olist_orders        AS o ON o.order_id = r.order_id
    JOIN olist_customers     AS c ON c.customer_id = o.customer_id
    GROUP BY 1, 2
)
SELECT
    s.order_month,
    s.customer_state,
    s.total_revenue,
    r.avg_review_score
FROM cube_sales   AS s
JOIN cube_reviews AS r
  ON s.order_month   = r.order_month
 AND s.customer_state = r.customer_state
ORDER BY 1, 2;
```

---

## 6. Drill-down

**Idea:** bajar en la jerarquía para ver datos más detallados.
Operación opuesta a roll-up.

Ejemplo: de año a mes.

```sql
-- Nivel año
WITH fact_olist_sales AS ( ... )
SELECT
    EXTRACT(YEAR FROM order_date) AS year,
    SUM(revenue)                  AS total_revenue
FROM fact_olist_sales
GROUP BY 1
ORDER BY 1;

-- Drill-down a nivel mes
WITH fact_olist_sales AS ( ... )
SELECT
    EXTRACT(YEAR  FROM order_date) AS year,
    EXTRACT(MONTH FROM order_date) AS month,
    SUM(revenue)                   AS total_revenue
FROM fact_olist_sales
GROUP BY 1, 2
ORDER BY 1, 2;
```

---

## 7. Drop measure

**Idea:** eliminar medidas del cubo, manteniendo dimensiones.

Ejemplo: pasar de varias medidas a una sola.

```sql
-- Cubo con varias medidas
WITH fact_olist_sales AS ( ... )
SELECT
    customer_state,
    date_trunc('month', order_date) AS order_month,
    SUM(price)                      AS sum_price,
    SUM(freight_value)              AS sum_freight,
    SUM(revenue)                    AS total_revenue
FROM fact_olist_sales
GROUP BY 1, 2;

-- Drop measure: nos quedamos solo con total_revenue
WITH fact_olist_sales AS ( ... )
SELECT
    customer_state,
    date_trunc('month', order_date) AS order_month,
    SUM(revenue)                    AS total_revenue
FROM fact_olist_sales
GROUP BY 1, 2;
```

---

## 8. Pivot (Rotate)

**Idea:** rotar ejes para ver una dimensión como columnas.

Ejemplo: estados como filas y estados de la orden como columnas.

```sql
SELECT
    customer_state,
    SUM(CASE WHEN order_status = 'delivered' THEN 1 ELSE 0 END) AS delivered_orders,
    SUM(CASE WHEN order_status = 'shipped'   THEN 1 ELSE 0 END) AS shipped_orders,
    SUM(CASE WHEN order_status = 'canceled'  THEN 1 ELSE 0 END) AS canceled_orders
FROM olist_orders AS o
JOIN olist_customers AS c ON c.customer_id = o.customer_id
GROUP BY customer_state
ORDER BY customer_state;
```

Esto es un “pivot” manual con agregación condicional.

---

## 9. Recursive roll-up

**Idea:** aplicar roll-ups sucesivos sobre una jerarquía recursiva hasta el nivel raíz.

El dataset Olist no trae una jerarquía recursiva real, así que este ejemplo es
esquemático. Supongamos que creas una tabla:

```sql
CREATE TABLE dim_product_category (
    category_id          INT PRIMARY KEY,
    parent_category_id   INT NULL REFERENCES dim_product_category(category_id),
    category_name        TEXT
);
```

Ejemplo de roll-up recursivo de ventas por categoría.

```sql
WITH RECURSIVE category_tree AS (
    -- Nivel raíz (categorías principales)
    SELECT
        category_id,
        parent_category_id,
        category_name,
        0 AS level
    FROM dim_product_category
    WHERE parent_category_id IS NULL

    UNION ALL

    -- Hijos
    SELECT
        c.category_id,
        c.parent_category_id,
        c.category_name,
        t.level + 1 AS level
    FROM dim_product_category AS c
    JOIN category_tree       AS t
      ON c.parent_category_id = t.category_id
),
sales_by_leaf AS (
    WITH fact_olist_sales AS ( ... )
    SELECT
        p.category_id,
        SUM(f.revenue) AS leaf_revenue
    FROM fact_olist_sales AS f
    JOIN dim_product_category AS p
      ON f.product_category_name = p.category_name
    GROUP BY p.category_id
)
SELECT
    t.category_name,
    t.level,
    SUM(s.leaf_revenue) AS revenue_rollup
FROM category_tree AS t
LEFT JOIN sales_by_leaf AS s
  ON t.category_id = s.category_id
GROUP BY t.category_name, t.level
ORDER BY t.level, t.category_name;
```

La idea es que, al agregar sobre el árbol, estás aplicando un roll-up recursivo.

---

## 10. Rename

**Idea:** renombrar elementos del esquema.

Ejemplo 1: alias a nivel de consulta (renombrar medida en vista OLAP).

```sql
WITH fact_olist_sales AS ( ... )
SELECT
    product_category_name AS category,
    SUM(revenue)          AS total_sales
FROM fact_olist_sales
GROUP BY product_category_name;
```

Ejemplo 2: renombrar una columna de tabla en PostgreSQL.

```sql
ALTER TABLE olist_orders
RENAME COLUMN order_purchase_timestamp TO order_ts;
```

---

## 11. Roll-up

**Idea:** agregar medidas siguiendo una jerarquía; vista más agregada.

Ejemplo: ROLLUP por estado y mes.

```sql
WITH fact_olist_sales AS ( ... ),
fact AS (
    SELECT
        customer_state,
        date_trunc('month', order_date) AS order_month,
        revenue
    FROM fact_olist_sales
)
SELECT
    customer_state,
    order_month,
    SUM(revenue) AS total_revenue
FROM fact
GROUP BY ROLLUP (customer_state, order_month)
ORDER BY customer_state, order_month;
```

Filas con `customer_state` o `order_month` nulos representan subtotales o total general.

---

## 12. Roll-up* (secuencia de roll-ups)

**Idea:** abreviatura para una secuencia de roll-ups.

Ejemplo conceptual (equivalente a aplicar varios roll-ups sobre tiempo):

```sql
WITH fact_olist_sales AS ( ... )
SELECT
    EXTRACT(YEAR  FROM order_date) AS year,
    EXTRACT(MONTH FROM order_date) AS month,
    EXTRACT(DAY   FROM order_date) AS day,
    SUM(revenue) AS total_revenue
FROM fact_olist_sales
GROUP BY ROLLUP (year, month, day)
ORDER BY year, month, day;
```

Este `ROLLUP (year, month, day)` es equivalente a una cadena de roll-ups:
diario, mensual, anual y total.

---

## 13. Slice

**Idea:** fijar un valor de una dimensión y eliminarla del cubo resultante.

Ejemplo: quedarse solo con el año 2017 (dimensión tiempo “cortada”).

```sql
WITH fact_olist_sales AS ( ... )
SELECT
    product_category_name,
    customer_state,
    SUM(revenue) AS total_revenue
FROM fact_olist_sales
WHERE EXTRACT(YEAR FROM order_date) = 2017
GROUP BY product_category_name, customer_state
ORDER BY product_category_name, customer_state;
```

La dimensión “año” ya no aparece, porque está fijada en 2017.

---

## 14. Sort

**Idea:** ordenar miembros de una dimensión según una expresión.

Ejemplo: top categorías por revenue.

```sql
WITH fact_olist_sales AS ( ... )
SELECT
    product_category_name,
    SUM(revenue) AS total_revenue
FROM fact_olist_sales
GROUP BY product_category_name
ORDER BY total_revenue DESC
LIMIT 10;
```

---

## 15. Union

**Idea:** unir celdas de dos cubos con mismo esquema y miembros disjuntos.

Ejemplo: cubo de ventas 2017 y cubo de ventas 2018.

```sql
WITH fact_olist_sales AS ( ... ),
cube_2017 AS (
    SELECT
        2017                          AS year,
        product_category_name,
        SUM(revenue)                  AS total_revenue
    FROM fact_olist_sales
    WHERE EXTRACT(YEAR FROM order_date) = 2017
    GROUP BY product_category_name
),
cube_2018 AS (
    SELECT
        2018                          AS year,
        product_category_name,
        SUM(revenue)                  AS total_revenue
    FROM fact_olist_sales
    WHERE EXTRACT(YEAR FROM order_date) = 2018
    GROUP BY product_category_name
)
SELECT * FROM cube_2017
UNION ALL
SELECT * FROM cube_2018;
```

