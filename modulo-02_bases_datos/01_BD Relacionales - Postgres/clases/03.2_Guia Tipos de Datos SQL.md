# Guía Tipos de Datos en Bases de Datos  

---

## 1. Tipos de Texto (Strings)

El contenedor más común, pero donde más errores de optimización se cometen.

| Tipo SQL   | Descripción                                                                                         | ¿Cuándo usarlo?                                                                   | Ejemplo Olist                                                                                           |
|-----------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------|
| `CHAR(n)` | Longitud fija. Reserva siempre el mismo espacio en memoria, aunque escribas menos. Muy rápido para buscar. | Cuando los datos tienen siempre el mismo tamaño (códigos, IDs, hashes).          | `customer_id` (siempre 32 caracteres hexadecimales). `zip_code` (siempre 5 dígitos).                    |
| `VARCHAR(n)` | Longitud variable. Se adapta al tamaño del texto. Ahorra espacio pero es un poco más lento que `CHAR`. | Para textos cortos o medios donde la longitud varía mucho.                       | `customer_city` (Sao Paulo es corto, Rio de Janeiro es largo). `order_status`.                         |
| `TEXT`    | Texto prácticamente ilimitado. Para párrafos o documentos enteros. No se suele indexar porque es lento. | Comentarios largos, descripciones de producto.                                   | `review_comment_message` (el cliente puede escribir una novela si quiere).                             |

**Regla de oro:**  
Si el dato siempre mide lo mismo (por ejemplo: CURP, RFC, DNI), usa `CHAR`.  
Si varía, usa `VARCHAR`.

---

## 2. Tipos Numéricos

Distinguir entre contar cosas y contar dinero es vital.

| Tipo SQL        | Descripción                                                                                   | ¿Cuándo usarlo?                                                                 | Ejemplo Olist                                                                                               |
|-----------------|-----------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------|
| `INT` / `INTEGER` | Números enteros, sin decimales.                                                              | Para contar cosas indivisibles o IDs secuenciales.                           | `product_photos_qty` (no puedes tener 2.5 fotos). `payment_installments` (número de cuotas).               |
| `DECIMAL(p,s)`  | Exactitud financiera. Tú defines la precisión (`p`) y la escala (`s`, número de decimales). No tiene errores de redondeo. | Siempre para dinero.                                                          | `price`, `freight_value`, `payment_value`. Por ejemplo, usar `DECIMAL(10,2)`.                              |
| `FLOAT` / `REAL` | Punto flotante. Números aproximados para cálculos científicos. Pueden tener errores de precisión (por ejemplo: 1.0000001). | Coordenadas geográficas, pesos físicos, distancias.                          | `geolocation_lat`, `geolocation_lng` (las coordenadas requieren precisión científica, no financiera).      |

**Alerta de novato:**  
Nunca uses `FLOAT` para dinero. Un error de redondeo de `0.0001` multiplicado por millones de transacciones puede significar muchas pérdidas.

---

## 3. Tipos de Fecha y Tiempo (Temporales)

El tiempo es complejo (zonas horarias, años bisiestos, etc.).

| Tipo SQL    | Descripción                                      | ¿Cuándo usarlo?                                             | Ejemplo Olist                                                                                 |
|-------------|--------------------------------------------------|-------------------------------------------------------------|-----------------------------------------------------------------------------------------------|
| `DATE`      | Solo la fecha (Año-Mes-Día). Sin hora.          | Cumpleaños, fecha de vencimiento de factura.               | `shipping_limit_date` (a veces solo importa el día límite).                                  |
| `TIMESTAMP` | Fecha y hora exacta (`YYYY-MM-DD HH:MM:SS`).    | Para registrar el momento exacto en que ocurrió un evento. | `order_purchase_timestamp` (necesitamos saber el segundo exacto de la compra para el stock). |
| `INTERVAL`  | Un periodo de tiempo (por ejemplo: `3 days`).   | Para calcular diferencias o SLAs.                          | Tiempo estimado de entrega (diferencia entre compra y entrega).                               |

---

## 4. Tipos Lógicos y Otros

| Tipo SQL | Descripción                            | ¿Cuándo usarlo?                                                        | Ejemplo Olist                                                                                                       |
|----------|----------------------------------------|------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------|
| `BOOLEAN`| Verdadero o falso (`TRUE` o `FALSE`).  | Flags o interruptores.                                                | Aunque no está en el CSV, podríamos crear `is_active` para los vendedores.                                         |
| `UUID`   | Identificador único universal.        | Para generar IDs únicos en sistemas distribuidos sin riesgo de colisión. | Los `order_id` de Olist son técnicamente UUIDs (aunque los guardamos como `CHAR(32)` por compatibilidad).         |
