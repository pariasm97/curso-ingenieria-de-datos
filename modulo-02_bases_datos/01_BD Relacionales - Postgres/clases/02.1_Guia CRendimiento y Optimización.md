# Clase: Rendimiento y optimización de consultas SQL con datos de Olist

## 1. Contexto y setup

La clase se centra en aprender a leer planes de ejecución, elegir índices razonables y entender el papel de las estadísticas (`ANALYZE`).

---

## 2. Objetivos de aprendizaje

Al finalizar la sesión, el estudiante será capaz de:

- Leer y entender un plan de ejecución básico con `EXPLAIN` y `EXPLAIN ANALYZE`.
- Identificar consultas ineficientes sobre las tablas de Olist.
- Aplicar técnicas simples de optimización:
  - Uso de índices.
  - Reducción de columnas (`SELECT` específico en vez de `SELECT *`).
  - Uso correcto de filtros en `WHERE`.
  - Mejora de `JOIN` y agregaciones.
- Entender cómo las estadísticas del planner (`ANALYZE`) afectan la elección de planes.
- Reconocer algunos anti-patrones típicos de consulta en escenarios analíticos.


---

## 3. Bloque 1 – Introducción y ejemplo “lento”

**Idea:** mostrar una consulta inocente pero costosa sobre Olist.

Ejemplo de consulta inicial:

```sql
SELECT
    o.order_id,
    c.customer_city,
    s.seller_city,
    p.product_category_name,
    oi.price,
    oi.freight_value,
    op.payment_type
FROM olist_orders o
JOIN olist_order_items oi ON o.order_id = oi.order_id
JOIN olist_customers c ON o.customer_id = c.customer_id
JOIN olist_sellers s ON oi.seller_id = s.seller_id
JOIN olist_products p ON oi.product_id = p.product_id
LEFT JOIN olist_order_payments op ON o.order_id = op.order_id;
```

Preguntas para el grupo:

- ¿Realmente necesitamos todas estas columnas para un primer análisis?
- ¿Faltan filtros por fecha, estado de orden, etc.?
- ¿Qué crees que podría pasar con el tiempo de ejecución en una tabla grande?


---

## 4. Bloque 2 – Medir: `EXPLAIN` y `EXPLAIN ANALYZE`

### 4.1. Conceptos clave

Explicar brevemente:

- El planificador de consultas decide el “camino” para ejecutar la consulta.
- Importancia de:
  - Costos estimados.
  - Filas estimadas vs filas reales.
- Operaciones frecuentes en los planes:
  - `Seq Scan` (escaneo secuencial).
  - `Index Scan`, `Index Only Scan`, `Bitmap Index Scan`.
  - `Nested Loop`, `Hash Join`, `Merge Join`.

### 5.2. Ejercicio guiado

Consulta base:

```sql
EXPLAIN ANALYZE
SELECT
    o.order_id,
    o.order_purchase_timestamp,
    c.customer_city,
    c.customer_state
FROM olist_orders o
JOIN olist_customers c ON o.customer_id = c.customer_id;
```

Actividades:

1. Ejecutar la consulta y revisar el plan.
2. Identificar:
   - Tablas que se escanean con `Seq Scan`.
   - Nodos más costosos (por tiempo total o filas procesadas).
3. Repetir con un filtro de fecha:

```sql
EXPLAIN ANALYZE
SELECT
    o.order_id,
    o.order_purchase_timestamp,
    c.customer_city,
    c.customer_state
FROM olist_orders o
JOIN olist_customers c ON o.customer_id = c.customer_id
WHERE o.order_purchase_timestamp >= '2017-01-01'
  AND o.order_purchase_timestamp < '2017-02-01';
```

Discutir los cambios de plan y de tiempos.

---

## 6. Bloque 3 – Índices, filtros selectivos y estadísticas del planner

### 6.1. Caso 1 – Filtrar órdenes por fecha y estado

Consulta base:

```sql
SELECT
    o.order_id,
    o.order_status,
    o.order_purchase_timestamp
FROM olist_orders o
WHERE o.order_status = 'delivered'
  AND o.order_purchase_timestamp >= '2017-01-01'
  AND o.order_purchase_timestamp < '2017-02-01';
```

Pasos:

1. Ejecutar `EXPLAIN ANALYZE` sin índices.
2. Observar:
   - ¿Usa `Seq Scan` sobre `olist_orders`?
   - ¿Cuántas filas lee en total?
   - Tiempo total.
3. Crear un índice compuesto:

```sql
CREATE INDEX idx_olist_orders_status_date
    ON olist_orders (order_status, order_purchase_timestamp);
```

4. Repetir `EXPLAIN ANALYZE` y comparar:
   - ¿Aparece `Index Scan` o `Bitmap Index Scan`?
   - ¿Cuántas filas lee ahora?
   - Diferencia en tiempo.

### 6.2. Caso 2 – Top productos más vendidos

Consulta:

```sql
SELECT
    oi.product_id,
    COUNT(*) AS num_items
FROM olist_order_items oi
GROUP BY oi.product_id
ORDER BY num_items DESC
LIMIT 20;
```

Discusión:

- ¿Un índice en `product_id` puede ayudar?

Probar:

```sql
CREATE INDEX idx_olist_order_items_product
    ON olist_order_items (product_id);
```

Volver a medir con `EXPLAIN ANALYZE` y analizar el plan.

### 6.3. Cómo elegir índices: guía práctica

Antes de crear cualquier índice, responder para cada consulta importante:

1. ¿Qué columnas aparecen en `WHERE`?
   - Ejemplos frecuentes en Olist:
     - Rango de fechas en `olist_orders.order_purchase_timestamp`.
     - `order_status` en `olist_orders`.
     - Filtrar por estado o ciudad del cliente (`customer_state`, `customer_city`).

2. ¿Qué columnas se usan para `JOIN`?
   - `olist_orders.customer_id` con `olist_customers.customer_id`.
   - `olist_order_items.order_id` con `olist_orders.order_id`.
   - `olist_order_items.product_id` con `olist_products.product_id`.
   - `olist_order_items.seller_id` con `olist_sellers.seller_id`.

3. ¿Qué columnas se usan en `ORDER BY` o `GROUP BY`?
   - `product_id` para top productos.
   - `order_purchase_timestamp` para orden cronológico.

4. ¿Qué tan grande es la tabla?
   - En tablas pequeñas, un índice puede no marcar diferencia.
   - En tablas grandes como `olist_orders` y `olist_order_items`, el índice suele aportar más.

5. ¿Qué tan selectivo es el filtro?
   - Filtrar por un solo estado de orden si casi todas están en ese estado puede ser poco útil.
   - Filtrar por rango de fechas corto suele ser más selectivo.

#### Reglas de bolsillo para esta clase

- Si una columna:
  - Aparece mucho en `WHERE` con igualdad o rango, y
  - La tabla es grande,  
  entonces es buen candidato a índice.

- En columnas de `JOIN`:
  - Asegurar `PRIMARY KEY` o `UNIQUE` en la tabla “padre” (ej: `olist_customers.customer_id`).
  - Considerar índice en la columna de `JOIN` de la tabla “grande” en sentido de lectura.

- Para filtros múltiples, considerar índices compuestos en el orden más usado:
  - Ejemplo: `(order_status, order_purchase_timestamp)` para consultas que filtran por estado y fecha.

#### Actividad – Diseño de índices con Olist

En grupos:

1. Diseñar 2 o 3 consultas de negocio, por ejemplo:
   - Ventas diarias por categoría de producto.
   - Top 10 sellers por valor de ventas en 2017.
   - Órdenes de clientes de cierto estado en un rango de fechas.

2. Para cada consulta:
   - Identificar columnas en `WHERE`, `JOIN`, `ORDER BY` y `GROUP BY`.
   - Proponer máximo 2 índices razonables.
   - Justificar en 2 o 3 frases.

3. Solo al final crear los índices y comparar los planes con `EXPLAIN ANALYZE` antes y después.

### 6.4. Estadísticas y `ANALYZE`: por qué el planner se equivoca

PostgreSQL decide si usa un índice apoyado en estadísticas de:

- Número de filas.
- Distribución de valores en cada columna.
- Histogramas, valores más frecuentes, etc.

Estas estadísticas se actualizan con:

```sql
ANALYZE olist_orders;
ANALYZE olist_order_items;
ANALYZE olist_customers;
```

En un entorno de laboratorio (carga manual de CSV), muchas veces las estadísticas no están actualizadas y el planner puede elegir un plan subóptimo.

#### Ejercicio – Ver el efecto de `ANALYZE`

1. Ejecutar una consulta sobre `olist_orders` y `olist_order_items` sin haber corrido `ANALYZE` explícito.
2. Ver en el plan:
   - Estimación de filas (`rows`).
   - Filas reales procesadas.
3. Ejecutar:

```sql
ANALYZE olist_orders;
ANALYZE olist_order_items;
ANALYZE olist_customers;
```

4. Repetir `EXPLAIN ANALYZE` y comparar:
   - ¿Cambió el plan?
   - ¿Mejoró la precisión de las estimaciones de filas?

- Un índice sin estadísticas frescas puede no ser usado.
- Después de grandes cargas de datos, es sano ejecutar `ANALYZE` sobre tablas críticas.
- Optimizar no es solo crear índices; también es dar al planner buena información.

---

## 7. Bloque 4 – Reescritura de consultas y `JOIN`

### 7.1. Evitar `SELECT *` y columnas innecesarias

Consulta pesada:

```sql
EXPLAIN ANALYZE
SELECT
    *
FROM olist_orders o
JOIN olist_order_items oi ON o.order_id = oi.order_id
JOIN olist_products p ON oi.product_id = p.product_id
WHERE o.order_purchase_timestamp::date = '2017-01-10';
```

Versión optimizada (solo columnas necesarias):

```sql
EXPLAIN ANALYZE
SELECT
    o.order_id,
    o.order_purchase_timestamp,
    p.product_category_name,
    oi.price
FROM olist_orders o
JOIN olist_order_items oi ON o.order_id = oi.order_id
JOIN olist_products p ON oi.product_id = p.product_id
WHERE o.order_purchase_timestamp::date = '2017-01-10';
```

Discusión:

- Menos ancho de fila implica menos I/O.
- Puede mejorar tiempos de red y de disco.

### 7.2. Funciones en columnas indexadas

Comparar:

```sql
-- Opción menos amigable para índices
WHERE o.order_purchase_timestamp::date = '2017-01-10';
```

con:

```sql
-- Opción que aprovecha mejor el índice
WHERE o.order_purchase_timestamp >= '2017-01-10'
  AND o.order_purchase_timestamp < '2017-01-11';
```

Actividad:

1. Crear índice sobre `order_purchase_timestamp`.
2. Ejecutar ambas consultas con `EXPLAIN ANALYZE`.
3. Comentar diferencias de plan.

---

## 8. Bloque 5 – Paginación y patrones de uso real

### 8.1. Paginación con `OFFSET`

Ejemplo:

```sql
EXPLAIN ANALYZE
SELECT
    o.order_id,
    o.order_purchase_timestamp,
    c.customer_city
FROM olist_orders o
JOIN olist_customers c ON o.customer_id = c.customer_id
ORDER BY o.order_purchase_timestamp DESC
LIMIT 50 OFFSET 5000;
```

Discusión:

- `OFFSET` grande obliga a saltarse muchas filas.
- Impacto en reportes y backoffice con muchos registros.

### 8.2. Paginación tipo “keyset” (por marcador)

1. Tomar la marca de la última fila de la página actual (por ejemplo, timestamp).
2. Usar esa marca como filtro en la siguiente página:

```sql
SELECT
    o.order_id,
    o.order_purchase_timestamp,
    c.customer_city
FROM olist_orders o
JOIN olist_customers c ON o.customer_id = c.customer_id
WHERE o.order_purchase_timestamp < '2018-01-01 10:00:00'
ORDER BY o.order_purchase_timestamp DESC
LIMIT 50;
```

---


## 9. Estrategias Avanzadas: Vistas Materializadas
Supongamos que se quiere un Dashboard que se actualiza cada hora con el "Total de Ventas Histórico por Estado del Cliente".

Calcular esto implica unir orders + customers + items. Hacerlo cada vez que alguien abre el dashboard es ineficiente.

Solución: Materialized View Calculamos el resultado una vez y lo guardamos físicamente.


```sql
CREATE MATERIALIZED VIEW mv_sales_by_state AS
SELECT 
    c.customer_state,
    SUM(i.price) as revenue
FROM olist_orders o
JOIN olist_customers c ON o.customer_id = c.customer_id
JOIN olist_order_items i ON o.order_id = i.order_id
WHERE o.order_status = 'delivered'
GROUP BY c.customer_state;

```

```sql
-- Crear un índice sobre la vista para lecturas rápidas
CREATE INDEX idx_mv_state ON mv_sales_by_state(customer_state);
Para actualizar los datos (ej. cada noche):
```

```sql
REFRESH MATERIALIZED VIEW mv_sales_by_state;
```

